{
  "hash": "284a5f87bc48d4b809e81512529b0297",
  "result": {
    "markdown": "# Manipulation de listes avec `purrr`\n\nSi vous n'avez besoin que de `purrr`, `library(purrr)` charge le package. Si vous utilisez tout le tidyverse, `purrr` sera chargée après :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n## Les listes c'est la vie\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- list(wagon1=\"pomme\", wagon2=1:3, wagon3=c(TRUE, FALSE))\nlength(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nnames(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"wagon1\" \"wagon2\" \"wagon3\"\n```\n:::\n\n```{.r .cell-code}\nstr(z)    # structure of z\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ wagon1: chr \"pomme\"\n $ wagon2: int [1:3] 1 2 3\n $ wagon3: logi [1:2] TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\n# View(z) # RStudio Viewer\nz         # simple print method\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$wagon1\n[1] \"pomme\"\n\n$wagon2\n[1] 1 2 3\n\n$wagon3\n[1]  TRUE FALSE\n```\n:::\n:::\n\nNe soyez pas effrayé·e par les listes : elles sont simplement des conteneurs pouvant accueillir des objets de classes différentes (ou non) et de longueur différentes (ou non). \n\nOn peut se figurer une liste comme un train dont les éléments seraient des wagons dont chacun contiendrait des conteneurs plus petits qui eux contiennent des éléments :\n\n```\n  --  wagon 1  --        --  wagon 2  --       --  wagon 3  --\n[    [\"pomme\"]    ] -- [    [ 1:3 ]     ] - [    [ c(TRUE, FALSE) ]    ]\n```\n\nUne liste s'indexe de plusieurs façons, positionnellement ou avec le nom de se(s) élément(s)-wagons s'ils sont nommés :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz[2]        # using positionnal index\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$wagon2\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nz[\"wagon2\"] # using [\"name\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$wagon2\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nclass(z[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n:::\n\nNotons que la syntaxe `z$wagon2` fonctionne aussi.\n\nSi l'on utilise les doubles crochets, on accède directement au contenu des caisses dans les wagons. Ces derniers ont perdu leurs natures de \"wagon\", ne sont plus des listes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz[[2]]        # using positionnal index\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nz[[\"wagon2\"]] # using [\"name\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nclass(z[[2]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n\nLes assignations `list[index] <-` et `list[[index]] <-` fonctionnent comme à l'acoutumée.\n\n\n## `map` à la vanille\n\nLe package `purrr` s'articule autour de la famille `map` dont il existe plusieurs variantes dont la première à voir est `map` tout court. \n\nL'idée est simple : appliquer une fonction à tous les éléments d'une liste et retourner une liste. La liste sera le premier argument de `map`, la fonction le second. Le nom de fonction est passé sans parenthèses :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(z, class)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$wagon1\n[1] \"character\"\n\n$wagon2\n[1] \"integer\"\n\n$wagon3\n[1] \"logical\"\n```\n:::\n:::\n\n## `map_*` et ses autres parfums\n\nDans l'exemple ci-dessus, si l'on ne veut pas de liste mais un vecteur (quand cela est possible), on peut utiliser `unlist` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz %>% map(class) %>% unlist()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     wagon1      wagon2      wagon3 \n\"character\"   \"integer\"   \"logical\" \n```\n:::\n:::\n\n\nMais quand la classe de sortie d'une fonction map est homogène et connue, on utilisera plutôt les variantes de map de la forme `map_*`. `*` pouvant prendre les valeurs `int` et `dbl` pour retourner des `numeric` sous forme d'entiers ou de doubles, `lgl` pour les vectuers logiques, `df`, `dfr` et `dfc` pour retourner des `data.frame`, éventuellement combinés par `r`ow ou `c`olonnes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz %>% map_chr(class)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     wagon1      wagon2      wagon3 \n\"character\"   \"integer\"   \"logical\" \n```\n:::\n\n```{.r .cell-code}\nlist(1:2, 4:9) %>% map_dbl(length)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 6\n```\n:::\n:::\n\n\n## `~` et `\\(x)` : les fonctions anonymes sont vos amies\n\nDans `purrr` et plus largement dans le tidyverse, on peut déclarer des fonctions anonymes, \"à la volée\" c'est à dire qu moment où l'on en a besoin. `purrr` mobilise l'opérateur `~` et la variable `.x`. \n\nR \"de base\" a repris l'idée dans une saveur un peu différente avec `\\(x)`. Ces trois approches sont équivalentes :\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:5 # create a vector\n# option 1 : using a named function\nsquare <- function(x) x^2\nmap_dbl(x, square)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1  4  9 16 25\n```\n:::\n\n```{.r .cell-code}\n# option 2 : purrr style anonymous function\nmap(x, ~.x^2)    \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 9\n\n[[4]]\n[1] 16\n\n[[5]]\n[1] 25\n```\n:::\n\n```{.r .cell-code}\n# option 3 : R base anonymous function\nmap(x, \\(x) x^2)  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 9\n\n[[4]]\n[1] 16\n\n[[5]]\n[1] 25\n```\n:::\n:::\n\n\n\n## `map2` et généralisation `pmap`\n\nImaginons que vous ayez deux listes `z1` et `z2` et que chaque élément de `z1` doivent être élevé à la puissance de chaque élément de `z2`. `purrr` généralise `map` avec deux listes avec les fonctions `map2_*` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz1 <- list(4:5, c(3, 2, 4.25), 1:3)\nz2 <- list(2, 1, 3)\nmap2(z1, z2, \\(x, y) x^y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 16 25\n\n[[2]]\n[1] 3.00 2.00 4.25\n\n[[3]]\n[1]  1  8 27\n```\n:::\n:::\n\n\nSi vous avez plus de trois listes, vous pouvez utiliser `pmap_`, comme suit. Le premier argument sera une liste de toutes vos listes. Imaginons qu'après avoir élevé à la puissance de `z2` nous voulions ajouter une valeur dans `z3` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz3 <- list(10, -5, 0)\npmap(list(z1, z2, z3), \\(x, y, z) x^y + z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 26 35\n\n[[2]]\n[1] -2.00 -3.00 -0.75\n\n[[3]]\n[1]  1  8 27\n```\n:::\n:::\n\n\n## Opérations sur listes\n\n## cheat sheet\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}