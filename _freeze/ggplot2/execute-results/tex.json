{
  "hash": "fb31a20d5f869ceab8ad1ef5f42b2485",
  "result": {
    "markdown": "# Graphiques avec `ggplot2`\n\n## Rationale\nIl est peu dire que le package `ggplot2` a changé la face de la représentation graphique en R.\n\nLe package de base, `graphics`^[`?graphics`] permet certes de tout faire mais laborieusement. D'autres packages (`lattice` par exemple) permettent une création plus proche de l'utilisateur·trice, moins proches des \"primitives\" (segments, points, etc.) graphiques.\n\nLa force de `ggplot2`, d'abord écrit par Hadley Wickham, est d'implémenter la _Grammar of Graphics_ de Leland Wilkinson qui dissocie les données de leurs représentations, de façon déclarative. Nous déclarerons ainsi à un jeu de données, des modes de représentation (des `geom_`) qui s'appuieront eux-mêmes sur des déclarations d'axes des abscisses, des ordonées, des couleurs, des tailles etc. (via `aes`), nous préciserons les axes (`coord_`), les paramètres de style `theme`. \n\nNous obtiendrons finalement un graphe que nous pourrons modifier à soit et qui sera même, en soit, une machine à faire d'autres graphes.\n\n`ggplot2` s'installe classiquement avec `install.packages(\"ggplot2\")` mais il est compris dans le tidyverse que vous avez du installer précédemment avec `install.packages(\"tidyverse\")`. \n\nPour charger `ggplot2`, il suffit de taper `library(ggplot2)` ou encore `library(tidyverse)`.\n\n## Un premier graphe\n\n`ggplot2` travaille sur des `data.frame`s (ou des `tibble`s mais c'est la même chose). Tout jeu de données qui n'est pas un `data.frame` sera converti ou tenté de l'être avec `fortify`. Le plus simple pour ne pas avoir de surprises étant de convertir vos données en un `data.frame` en bonne et due forme, vous-mêmes.\n\nNous allons utiliser `iris` qui est déjà un `data.frame` mais que nous allons, pour la cosmétique, convertir en `tibble` et en renommer les colonnes\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\niris2 <- iris %>% \n  as_tibble() %>% \n  rename(pl=Petal.Length, pw=Petal.Width,\n         sl=Sepal.Length, sw=Sepal.Width, sp=Species)\niris2 # iris, as tibble and with more compact column names\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 x 5\n      sl    sw    pl    pw sp    \n   <dbl> <dbl> <dbl> <dbl> <fct> \n 1   5.1   3.5   1.4   0.2 setosa\n 2   4.9   3     1.4   0.2 setosa\n 3   4.7   3.2   1.3   0.2 setosa\n 4   4.6   3.1   1.5   0.2 setosa\n 5   5     3.6   1.4   0.2 setosa\n 6   5.4   3.9   1.7   0.4 setosa\n 7   4.6   3.4   1.4   0.3 setosa\n 8   5     3.4   1.5   0.2 setosa\n 9   4.4   2.9   1.4   0.2 setosa\n10   4.9   3.1   1.5   0.1 setosa\n# i 140 more rows\n```\n:::\n:::\n\n\nLes étapes suivantes sont toujours les mêmes :\n\n1. déclarer le `data.frame`à utiliser (`iris2` ici)\n2. déclarer quelles colonnes doivent être utilisées (nous voulons la largeur de pétale `pw` en fonction, en `y` en somme, de la longueur de pétale `pw`).\n3. déclarer le mode de représentation (ici un nuage de points `geom_point`, mais quantité d'autres `geom` existent comme les histogrammes, les boxplots, etc.)\n\n`ggplot2` utilise l'opérateur `+` pour assembler ces différentes couches, après la fonction `ggplot()` qui initie le graphe.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris2 %>% \n  ggplot() + \n  aes(x=pl, y=pw) + \n  geom_point()\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-3-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nVous trouverez parfois la déclaration du `data.frame` `aes` au sein de `ggplot()` comme cela : `ggplot(iris2, aes(x=pw, y=pl))`. J'ai tendance à tout éclater comme ci-dessus, mais à vous de voir.\n\n## Un deuxième `geom` et un sacrifice\nSi vous vous amusiez à compter le nombre de points représentés, ou plus intelligemment `iris2 %>% select(pl, pw) %>% unique() %>% nrow()`, vous réaliseriez que 42 points ne sont pas visibles. La faute n'en incombe nullement à `ggplot2` mais à la précision des instruments de mesure au moment de l'acquisition de données ! Plus exactement, ils sont visibles mais superposés. \n\nCette mise en garde nous donne l'occasion de présenter un deuxième `geom` qui introduit suffisamment de bruit dans les données pour que tous les points soient représentés tout en gardant la relation générale entre les deux variables `pw` et `pl`. En d'autres termes, nous sacrifions l'exactitude pour gagner en fidélité du nombre de points effectivements présents.\n\nLa représentation visuelle de l'information quantitative est souvent affaire de sacrifices et elle est un domaine de recherche à part entière. Offrez-vous ou faites vous offrir la bibliographie complète d'Edward Tufte !\n\nVoilà un `iris2` avec ses 150 iris :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris2 %>% \n  ggplot() + \n  aes(pl, pw) + \n  geom_jitter()\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-4-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n## `aes` : d'autres variables sur le même graphe\n\n`aes` règle les _aesthetics_ de votre `ggplot`. Si par exemple vous voulez associer chaque espèce à une couleur, il vous suffit de rajouter `col=sp` dans `aes()` et la légende est automatiquement générée :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris2 %>% ggplot() + \n  aes(pl, pw, col=sp) +\n  geom_jitter()\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-5-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nDans le même esprit, si vous vouliez rajouter les dimensions des sépales comme encodage des tailles de point, c'est dans `aes()` que ça se passe. Vous pouvez même créer à la volée, dans `aes` même, des opérations sur les colonnes de `iris2`. Une \"pseudo-aire\", faisant fi de la forme mais intégrant la longueur et la largeur des sépales peut se créer comme suit :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris2 %>% ggplot() + \n  aes(pl, pw, col=sp, size=sw*sl) +\n  geom_jitter()\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-6-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n## Tendances et modèles statistiques\n\nLa production de graphes est centrale dans l'exploration de données et `ggplot2` en fait une tâche simple. `stat_smooth` va ajouter une courbe de tendance aux données représentées.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg <- iris2 %>% ggplot() + aes(pl, pw) + geom_point() \ngg + stat_smooth()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-7-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nDeux choses. D'abord, `ggplot2` vous avertit que la courbe ajoutée utilise `loess`, c'est à dire un ajustement polynomial local calé sur `y~x`. Si ces messages vous ennuient, il vous suffit de préciser à `geom_smooth` d'utiliser ces modèles (`geom_smooth(method=\"loess\", formula=\"y~x\")`). Ensuite, peut être vous aviez plutôt en tête un bon vieux modèle linéaire avec `lm` plutôt que ce `loess` certes flatteur mais qui ne sied peut-être pas à votre esprit naturellement parcimonieux. Bonne nouvelle, c'est très simple :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg + geom_smooth(method=\"lm\", formula=\"y~x\")\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-8-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nAprès avoir contemplé ce graphe, vous vous dites que ce modèle linéaire, moyennant que la longueur de pétale soit inférieure à 2 vous prédirait des largeurs de pétales négatives. Ce qui vous en conviendrez n'a guère de sens, ni pour un·e biologiste, ni même pour un·e statisticien·ne (c'est dire !).\n\nVous l'avez deviné si vous avez déjà utilisé `lm()`, ça se passe dans dans la spécification de la `formula`. Pour forcer le modèle à ne pas avoir d'intercept (ou plutôt un intercept égal à 0), vous pouvez spécifier `-1` dans la formule. Je sais que ce n'est pas très intuitif mais vous consulterez avec volupté `?formula` pour plus d'informations.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg + geom_smooth(method=\"lm\", formula=\"y~x-1\")\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-9-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nDans le même esprit si nous voulions forcer la relation à être quadratique, nous aurions pu :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg + geom_smooth(method=\"lm\", formula=\"y~I(x^2)+x-1\")\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-10-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nLa couleur de la droite (ou de la courbe) de régression, ainsi que la présence ou non d'un intervalle de confiance peuvent se préciser, toujours dans `geom_smooth`. Par exemple :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg + geom_smooth(method=\"lm\", formula=\"y~x-1\", se=FALSE, col=\"red\", linetype=\"dashed\")\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-11-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nCes paramètres `se` et `colour` sont documentés dans `?geom_smooth` et ne s'appliquent qu'à ce `geom`, pas à l'échelle globale du `ggplot` ni même des autres `geom`s. Par exemple :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg + \n  geom_smooth(method=\"lm\", formula=\"y~x\", col=\"green\", se=FALSE) +\n  geom_smooth(method=\"lm\", formula=\"y~x-1\", col=\"purple\") # no intercept\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-12-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nUn petit rappel à la doxa ne faisant jamais de mal : \n\n> ce n'est pas parce que produire des droites/courbes de tendance est facile que vous êtes autorisé·e à le faire\n\nSi votre modèle n'est pas \"significatif\", vous n'êtes pas vraiment autorisé·e à le représenter. Naturellement vous pouvez le faire en cachette mais dans un article vous allez vous faire tomber dessus par le·a post-doc qui se tape la review !\n\nIl n'y a aucun moyen à ma connaissance de le faire avec `ggplot2`, ni même de récupérer les modèles créés en interne par ce dernier mais vous aurez, quoiqu'il en soit, besoin de les explorer par ailleurs. Recréeons le modèle sans intercept :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- lm(pw~pl-1, data=iris2)\nmod\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = pw ~ pl - 1, data = iris2)\n\nCoefficients:\n    pl  \n0.3365  \n```\n:::\n\n```{.r .cell-code}\nsummary(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = pw ~ pl - 1, data = iris2)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.48446 -0.24366 -0.13699  0.08642  0.68379 \n\nCoefficients:\n   Estimate Std. Error t value Pr(>|t|)    \npl 0.336511   0.005063   66.46   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.2573 on 149 degrees of freedom\nMultiple R-squared:  0.9674,\tAdjusted R-squared:  0.9672 \nF-statistic:  4417 on 1 and 149 DF,  p-value: < 2.2e-16\n```\n:::\n:::\n\n\n\nSans surprise, le modèle linéaire est \"significatif\" et le(s) R2 excellents. Vous pouvez donc représenter ces modèles.\n\nLe clou du spectacle désormais : si nous avons déclaré une couleur par espèce d'iris, le reste suit. Le reste ici étant un modèle linéaire. Tadan !\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg <- iris2 %>% \n  ggplot() + \n  aes(pl, pw, col=sp) +\n  geom_point() +\n  geom_smooth(method=\"lm\", formula=\"y~x\")\n```\n:::\n\n\n\nNotons que si vous ne voulez PAS que le reste suive, en termes plus formels que `geom_smooth()` n'hérite pas des paramètres globaux de `aes`, il vous suffit de déclarer un `aes` local au paramètre `mapping`, le premier argument de tous les `geom` :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris2 %>% \n  ggplot() + \n  aes(pl, pw, col=sp) +\n  geom_point() +\n  geom_smooth(mapping = aes(col=NULL), method=\"lm\", formula=\"y~x\")\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-15-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n## Interlude cosmétique : `labs`, `theme` et `scale_`\n\nPuisque je sens que vous commencez à tomber éperdument amoureux·se de `ggplot2`, il est temps d'enfoncer le clou avec un peu de cosmétique.\n\nLe nom des axes ainsi que les titres et sous-titres sont faciles à modifier :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg <- gg + \n  xlab(\"Petal length (mm)\") + \n  ylab(\"Petal width (mm)\") + \n  labs(title=\"Another iris graph\", subtitle = \"beware of those who don't like flowers\")\ngg\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-16-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nLe \"thème\" général des graphes peut être modifié. Vous pouvez essayer les autres, tapez `theme_` puis pressez `<Tab>`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg + theme_minimal()\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-17-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nChaque élément individuel peut être modifié. Sachez que c'est un terrain glissant, susceptible de vous désociabiliser. Avec un peu de sueur on fait exactement ce que l'on veut, y compris pire :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg + theme(axis.title.x = element_text(face=\"bold\"),\n           axis.text.y = element_text(angle=45),\n           panel.background = element_rect(fill=\"pink\"))\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-18-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nSi l'un des thèmes vous convient et/ou que vous en avez customisé un, vous pouvez le définir pour tous les graphes avec `theme_set`.\n\nEnfin, et l'on s'écarte un peu de la pure cosmétique, vous pouvez ajuster les systèmes de représentation des axes, à commencer par leurs limites :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg + scale_x_continuous(limits=c(0, 8))\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-19-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nPour la seule étendue, on préferera `xlim()` et `ylim()` mais la fonction `scale_x_continuous` fait beaucoup plus.\n\nVous pouvez même changer le système de coordonnées. Si par exemple vous représentez un plan factoriel d'ACP, vous aurez besoin de contraindre l'aspect `y/x` de telle façon qu'un centimètre sur `x` à l'écran, représente également un centimètre sur `y`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg + coord_equal()\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-20-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nLes régressions sont moins flatteuses [^renard] mais on a bel et bien un plan euclidien.\n\n[^renard]: petite filouterie : si vous voulez convaincre visuellement, arrangez vous pour que vos regressions aient un angle de 45°\n\nEnfin, vous pétez les plombs et vous vous lancez dans l'étude des vents, ou quoique ce soit d'autre avec des coordonées polaires. La famille `coord_*` vous permet de changer carrément le système de coordonées :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg + coord_polar()\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-21-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n`coord_flip` vous sera aussi utile si vous désirez culbuter le graphe et passer les `x` en `y` et vice-versa.\n\n## `geom` (suite) : deux variables continues\n\nMoult autres `geom`s sont disponibles dans `ggplot2` et sont présentés graphiquement [ici](https://ggplot2.tidyverse.org/reference/#layers).\n\nPour continuer sur deux variables continues, on pourra rajouter facilement des courbes ou autres éléments de densité. Toutes les opérations kernel sont faites pour vous donc vous n'avez pas vraiment à vous en soucier. 150 points c'est un peu limite pour ces fonctions mais restons fidèles à `iris` :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg <- iris2 %>% ggplot() + aes(pl, pw)\ngg + geom_density2d()\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-22-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\ngg + geom_bin_2d()\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-22-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nNaturellement, vous pouvez rajouter les points. L'ordre de représentation est celui des déclarations. Si vous passez `geom_point` après `geom_density2d`, les points seront représentés au-dessus des courbes de densité :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg + geom_density2d_filled(col=\"grey90\") + geom_point(col=\"white\") + coord_equal()\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-23-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nClassieux n'est-ce pas ?\n\n## `geom` (suite) : une seule variable continue\n\nQuand vous n'avez qu'une seule variable continue c'est vraisemblablement que vous vous intéressez à sa distribution, c'est à dire que vous voulez un histogramme ou sa densité, selon que vous vouliez binner vos données ou les garder continues. Quelques exemples ci-dessous et je vous laisse explorer en autonomie.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg <- iris2 %>% ggplot() + aes(pl)\ngg + geom_histogram()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-24-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\ngg + geom_density()\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-24-2.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\ngg + geom_dotplot()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nBin width defaults to 1/30 of the range of the data. Pick better value with\n`binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-24-3.pdf){fig-pos='H'}\n:::\n:::\n\n\n> Quand `ggplot2` et plus généralement `R` vous enquiquine avec un message c'est souvent pour votre bien.\n\n## `geom` (suite) : une variable continue et un facteur\n\n`ggplot2` a tout ce qu'il vous faut pour représenter des boxplots et variantes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg <- iris2 %>% ggplot() + aes(x=sp, y=pl, fill=sp)\ngg + geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-25-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\ngg + geom_violin() + geom_jitter() + coord_flip()\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-25-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n## Les sous-graphes avec `facet_`\n\nUne famille de fonction très puissante en `ggplot2` est celle des `facet_` qui vous permettent de faire des `sous-graphes` facilement. Pour que l'exemple soit encore plus aiguisé, nous allons créer une autre colonne facteur dans `iris2` simulant cinq sessions de terrain, de mesure de 10 iris par espèce par session. Puis nous allons créer un graphe de base, l'occasion de montrer l'utilisation de `shape`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris2 <- iris2 %>% mutate(session=factor(rep(rep(LETTERS[1:5], each=10), 3)))\ngg <- iris2 %>% ggplot() + \n  aes(pl, pw, col=sp, shape=session) + \n  geom_jitter() + geom_smooth(method=\"lm\", formula=\"y~x-1\", se=FALSE) +\n  theme_linedraw()\ngg\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-26-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nNous conviendrons qu'on y voit goutte. Surtout entre sessions. `facet_grid` est votre ami. Vous pouvez spécifier qui va en ligne, qui va en colonne et si les échelles doivent être fixes ou peuvent être libres. Quelques exemples :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg + facet_grid(session~sp)\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-27-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\ngg + facet_grid(.~sp, scales=\"free\")\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-27-2.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\ngg + facet_grid(session~., scales=\"fixed\")\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-27-3.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nPratique ! Notez que quand vous ne voulez qu'une dimension, vou spouvez omettre l'un des membres à gauche ou à droite et le remplacer par un `.`. [^facet]\n\n[^facet]: et `~sp` sans point à gauche fonctionnerait aussi.\n\n`facet_wrap` est plus lâche dans sa définition et ne veut qu'une seule colonne, dont les sous-graphes correspondant seront simplement enroulés selon des dimensions plaisantes, que vous pouvez spécifier :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg + facet_wrap(~session, nrow=2)\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-28-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n## Interlude cosmétique : `scale_` (suite) et `guides`\n\nSi vous ne vous pâmez pas devant les couleurs par défaut, il est naturellement possible de les changer avec une des fonctions `scale_color_*`. Il en va de même pour les autres modes de représentation définis dans `aes`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg <- iris2 %>% ggplot() + aes(pl, pw, col=sp, size=sl) + geom_point()\ngg + scale_color_viridis_d(option = \"B\") + scale_size(range=c(0.5, 2))\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-29-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nJe vous laisse explorer les `scale_` en autonomie. Oui, il y a moyen d'y passer des journées. Le choix des couleurs est un sujet central car il faut penser à tout le monde : les daltoniens, les imprimantes noir et blanc. Et encore plus largement la perception des couleurs par l’œil et le cerveau humains.\n\nVous pouvez également ne pas vous en réferer à des palettes pré-construites et fixer vos propres couleurs avec un vecteur nommé et l'une des fonctions `scale_*_manual` :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsp_cols <- c(\"setosa\"=\"navyblue\", \"versicolor\"=\"purple\", \"virginica\"=\"firebrick3\")\ngg + scale_color_manual(values=sp_cols)\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-30-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n## `%+%` : une fabrique à graphes\n\nPlus haut, je vous ai promis que les graphes `ggplot2` étaient en soit des machines à faire des graphes^[on pourrait parler de fonctions, voire de fonction factories]. Imaginons que nous disposions d'un autre jeu de données se présentant de la même façon, typiquement avec les mêmes colonnes utilisées par un `ggplot` que vous auriez construit avec amour et simplicité :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg <- ggplot(iris2) + aes(pl, pw, col=sp) + geom_point()\ngg\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-31-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nEt voilà un autre jeu de données, avec un peu de bruit gaussien pour tout le monde :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris_bis <- iris2 %>% mutate(across(c(pl, pw), ~.x+rnorm(.x, sd=0.5)))\niris_bis\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 150 x 6\n      sl    sw    pl      pw sp     session\n   <dbl> <dbl> <dbl>   <dbl> <fct>  <fct>  \n 1   5.1   3.5 1.91   0.335  setosa A      \n 2   4.9   3   1.31  -0.0591 setosa A      \n 3   4.7   3.2 1.30   0.271  setosa A      \n 4   4.6   3.1 0.762  0.547  setosa A      \n 5   5     3.6 0.973  0.385  setosa A      \n 6   5.4   3.9 1.02   0.734  setosa A      \n 7   4.6   3.4 1.19   0.415  setosa A      \n 8   5     3.4 1.12   0.208  setosa A      \n 9   4.4   2.9 1.12   0.582  setosa A      \n10   4.9   3.1 1.57   0.682  setosa A      \n# i 140 more rows\n```\n:::\n:::\n\n\n\nNous pouvons remplacer le jeu de données utilisé initialement par `gg` (c'est à dire `iris2`) par votre nouveau jeu de données (c'est à dire `iris_bis`), en utilisant l'opérateur `%+%` :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg %+% iris_bis\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-33-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nVous pouvez même modifier le ggplot ainsi obtenu. Ci-dessous, je pousse le bouchon jusqu'à manipuler au tout dernier moment `iris_bis` pour ajouter un numéro d'individu séquentiel et ajouter une étiquette avec `geom_label`, une variante de `geom_text`, tous deux bien utiles.\nÀ y être, je rajouter aussi une petite annotation, alignée à gauche sur le point `(1; 2.5)`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngg2 <- gg %+% mutate(iris_bis, i=1:n()) + \n  geom_label(aes(label=i)) + \n  annotate(\"text\", x=1, y=2.5, label=\"hello\", hjust=0)\ngg2\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-34-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n## Un package bien utile : `patchwork`\n\nQuantité de packages existent pour étendre encore les fonctionnalités de `ggplot2`. Nous pouvons citer :\n\n* `plotly` : pour des graphes interactifs\n* `ggmap` : gestion des données spatiales et des projections\n* `ggrepel` : pour avoir des étiquettes de données non juxtaposées\n* `ggdendro`: representer des dendrogrammes et autres arbres\n* etc.\n\nNous ne présenterons que `patchwork`: qui permet l'assemblage intuitif de graphes. Son fonctionnement est simplissime. Si vous avez plusieurs `ggplot` vous pouvez les assembler, comme des \"méta-facet\" en quelque sorte. Les opérateurs `+` et `/` construisent un seul `ggplot` juxta- ou superposés :\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(patchwork)\ngg + gg2\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-35-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\ngg / gg2\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-35-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n`plot_layout` et `plot_annotation` sont très utiles pour des compositions plus sophistiquées.\n\nEnfin, si vous avez non pas deux mais une quantité de graphes, par exemple dans une liste, `wrap_plots` fait le job.\n\nImaginons que je vous ai convaincu·e de ne désormais plus faire de terrain et de simuler vos données. Imaginons que vous simuliez `K`, disons 6, sessions de mesures. \n\nLe `map` ci-dessous fera l'objet de tout le chapitre suivant. Ici, un simple aperçu de sa puissance.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nK=6\n# simulate data\niris6 <- map(seq_len(6), \n              ~iris2 %>% mutate(across(c(pl, pw), ~.x+rnorm(.x, sd=0.5))))\n# build the ggs\ngg6 <- map(iris6, ~ gg %+% .x)\n# patchwork them\nwrap_plots(gg6, ncol=3) + plot_layout(guides=\"collect\")\n```\n\n::: {.cell-output-display}\n![](ggplot2_files/figure-pdf/unnamed-chunk-36-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n## Sauvez vos créations avec `ggsave`\n\nUne fois que vous êtes satisfait·e de votre `ggplot`, vous pouvez le sauver vers un `pdf`, `eps`, `jpg`, `png`, etc. facilement avec la fonction `ggsave`.\n\nIl vous suffit d'appeller `ggsave` avec le nom de fichier et son extension correspondant au format que vous voulez sauver. Vous pouvez aussi spécifier la largeur et la hauteur de sortie. Par défaut `ggsave` sauve le dernier graphe produit mais vous pouvez spécifier l'argument `plot` de `ggsave`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggsave(\"my_plot_1.pdf\", gg, width=12, height=8)\n```\n:::\n\n\n\n\n## Considérations post-liminaires\n\n`ggplot2` peut-être frustrant dans les premiers temps. Comme vous le savez la frustration est typique mais temporaire. `ggplot2` mérite définitivement de s'y accrocher et les larmes de hargne seront bientôt remplacées par des cris de joie et des apéros en terrasse grâce au temps gagné.\n\n",
    "supporting": [
      "ggplot2_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}