{
  "hash": "8f255bda1716abc8c0d2b81d4207b674",
  "result": {
    "engine": "knitr",
    "markdown": "# Fonctions\n\n\nLes fonctions sont généralement abordées plus tard mais je crois non seulement en vous mais aussi qu'elles peuvent et doivent être démystifiées précocément. Nous allons commencer par la partie créative et écrire notre première fonction.\n\n## Une première fonction\n\nNous pouvons définir nos propres fonctions en utilisant la fonction `function`.\n\nNous allons ensuite encapsuler une portion de code entre des accolades `{` et l'assigner comme tout autre objet R.\n\nDéfinissons une fonction qui ajoute `3`  à un argument que l'on va appeller `x` (vous pouvez essayer avec `y` ou `toto` :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplus3 <- function(x) {\n  x+3\n}\n\nplus3(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n\n```{.r .cell-code}\nplus3(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 5 6\n```\n\n\n:::\n:::\n\n\n\nLes fonctions permettent de ne pas copier-coller bêtement du code, de dupliquer des lignes. Dès que vous répétez un bout de code, vous pouvez profitablement en faire une fonction.\n\nÀ terme, cela vous permettra d'avoir du code non dupliqué, moins propice à des erreurs de frappes.\n  \nAussi, si vous changez d'avis, vous pourrez changer la définition de fonction et, chaque fois qu'elle sera appelée en aval, le nouveau comportement sera appliqué. Nous reviendrons sur ces bonnes pratiques à la toute fin de cette formation.\n\nL'expérience vous guidera sur quand et comment créér des fonctions à la bonne granularité, c'est à dire les plus génériques possibles mais dans les limites du bon sens. \n\n## Documentation des fonctions\n\nLes fonctions sont des unités de code qui font quelque chose d'utile. Le plus souvent on envoie une valeur, un objet, et on en récupère une autre mais certaines produisent quelque chose \"ex nihilo\" `sqrt()` par exemple renvoie la racine carrée de la valeur _passée_ en _argument_.\n\nLes arguments, séparés par des virgules, définissent les \"options\" de la fonction concernée. Une fonction peut avoir zéro, un, plusieurs et même un nombre indéfini d'argument.\n\nToute fonction déjà disponible en R ou un package a forcément une page d'aide dédiée à laquelle on accède avec : `?nom_de_la_fonction`. \n\nRevenons à notre fonction `seq` bien pratique pour créer des `seq`uences régulières. En tapant `?seq` on accède au contenu suivant :\n\n```\nSequence Generation\n\nDescription\nGenerate regular sequences. seq is a standard generic with a default method. seq.int is a primitive which can be much faster but has a few restrictions. seq_along and seq_len are very fast primitives for two common cases.\n\n## Default S3 method:\nseq(from = 1, to = 1, by = ((to - from)/(length.out - 1)),\n    length.out = NULL, along.with = NULL, ...)\n\nseq.int(from, to, by, length.out, along.with, ...)\n\nseq_along(along.with)\nseq_len(length.out)\n\nArguments\n[...]\n\nDetails\n[...]\n\nValue\n[...]\n\nSee also\n[...]\n\nExamples\n[...]\n\n```\n\nToutes les pages d'aides ont la même structure et possèdent les mêmes sections. Regardons-les de plus près :\n\n* **Description** : ce que la fonction fait\n* **Usage** : la fonction \"déployée\" c'est à dire avec tous ses arguments. Parfois plusieurs fonctions sont regroupées dans une même age d'aide, comme c'est le cas pour `seq`. Ces fonctions peuvent être des variantes avec des noms différents ou des **méthodes** c'est à dire des fonctions au comportement différent selon le type d'objet sur lequel elles opèrent.\n* **Arguments** : un descriptif de tous les arguments disponibles. La classe et le format de chacun d'eux est mentionnée.\n* **Details** : souvent un remède à l'insomnie mais les subtilités d'implémentation sont là, souvent cachées au détour d'une phrase.\n* **Value** : ce que la fonction retourne.\n* **References** : où s'en référer si vous n'en avez pas assez\n* **See Also** : fonctions connexes, très pratique pour enrichir son vocabulaire et trouver son bonheur.\n* **Examples** : peut être la plus utile de toutes avec ses exemples d'utilisation que vous pouvez copier-coller ou même appeller directement depuis la console avec `example(\"nom_de_la_fonction\")`. Vous pouvez essayer `example(\"plot\")` par exemple.\n* En pied de page, vous avez également une information qui sera utile plus tard : le package et sa version dans lequel se trouve être cette fonction. Pour `seq`, on est dans le package `base` dont toutes les autres fonctions sont indexées dans le lien \"Index\".\n\nCertaines pages d'aide, surtout pour le langage lui-même, sont plutôt des résumés du fonctionnement et sont un peu moins intuitives à trouver, par exemple `?Arithmetic`, `?Special`, `Syntax`.\n\nD'autres fonctions, par exemple pour les opérateurs, doivent être encadrées de guillemets arrières (`` ` ``), par exemple `` ?`+` `` ou la mise en abyme de `` ?`?` ``. Enfin, il existe d'autres ressources comme les \"vignettes\", plus conviviales, surtout pour les packages les plus récents. Nous y reviendrons.\n\nLes pages d'aide sont souvent compactes et obscures mais l'information que vous cherchez est probablement là. On apprend beaucoup à lire ces pages d'aide même si à première vue cette littérature n'est guère attrayante.\n\nEnfin, la variante `??(quoiquoiquoi)`, raccourci de `help.search(\"quoiquoiquoi\")` permet de chercher toutes les occurences de `quoiquoiquoi` dans _toutes_ les pages d'aide de R.\n\n## Arguments : paramétrer le comportement des fonctions\n\nAprès avoir consulté `?seq` on peut par exemple préciser le point de départ (`from`), le point d'arrivée (`to`), le pas (`by`) et la longueur totale du vecteur à créer (`length.out`).\n\nVous constaterez que `from` est défini avec une valeur par défaut (`from=1`). Ainsi, si vous omettez sa valeur et ne spécifiez que `to`, `from` prendra sa valeur par défaut. Ces deux commandes sont donc équivalentes :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(from=1, to=5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(to=5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n:::\n\n\n\nVous pouvez également abréger le nom des arguments, moyennant que l'abbréviation soit univoque, c'est à dire que le nom de l'argument que vous abrégez ne soit pas identique à celui d'un autre argument. Ainsi `from` et `length.out` peuvent être abrégés en `fr` et `length`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(fr=0, to=2, length=5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.0 0.5 1.0 1.5 2.0\n```\n\n\n:::\n:::\n\n\n\nCe n'est jamais une bonne idée mais si vous utilisez le nom complet ou une abbréviation des arguments vous pouvez changer leur ordre. Ainsi `seq(length=5, to=2, fr=0)` sera équivalent à la commande précédente.\n\nVous pouvez même omettre le nom des arguments comme on l'a fait dans les sections précédentes sans le mentionner. Dans ce cas, les arguments sont passés positionnellement et doivent être renseignés dans l'ordre tel que défini dans la section 'Usage' de leur documentation:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(-3, 4, 12)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -3\n```\n\n\n:::\n:::\n\n\n\n## Une deuxième fonction\n\nSi vous avez bien compris la section précédent, alors le deuxième exemple avec deux arguments, et des valeurs par défaut, devrait vous paraître limpide :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_this <- function(x=1, y=0){\n  x+y\n}\n\nadd_this()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nadd_this(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\nadd_this(y=7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n\n```{.r .cell-code}\nadd_this(2, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12\n```\n\n\n:::\n:::\n\n\n\n## Accéder au code interne des fonctions\n\nLe code des fonctions est toujours accessible, le plus souvent simplement en tapant le nom des fonctions, sans parenthèses.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplus3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<srcref: file \"\" chars 1:10 to 3:1>\n<bytecode: 0x7ffccaf53928>\n```\n\n\n:::\n\n```{.r .cell-code}\nadd_this\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<srcref: file \"\" chars 1:13 to 3:1>\n<bytecode: 0x7ffccaee0508>\n```\n\n\n:::\n:::\n\n\n\nParfois le code est lové dans des Primitives (des fonctions non écrites en R) ou bien dans des méthodes (des fonctions qui changent de comportement suivant le type d'objet qu'on leur passe). Nous y reviendrons.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (...)  .Primitive(\"c\")\n```\n\n\n:::\n\n```{.r .cell-code}\nseq\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (...) \nUseMethod(\"seq\")\n<bytecode: 0x7ffccbf16a00>\n<environment: namespace:base>\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}