{
  "hash": "7525221b42872890d86b1bbebd740df0",
  "result": {
    "engine": "knitr",
    "markdown": "# Ceci n'est pas qu'un opérateur : `%>%` et `magrittr`\n\n## L'opérateur pipe %>%\n\nL'opérateur pipe permet de passer, de gauche à droite, le résultat d'une fonction à une seconde fonction, puis à une troisième. Ce pipe est détaillé dans un chapitre mais sa compréhension devrait être intuitive.\n\nComparez par exemple ces deux lignes pourtant strictement équivalentes :\n\n{r}\nlibrary(magrittr)\nplot(sqrt(sample(seq(1:100), 6)))              # road to burnout\nseq(1:100) %>% sample(6) %>% sqrt() %>% plot() # let's breathe\n\nLes packages du R moderne, en premier lieu ceux du tidyverse en ont fait une idée centrale de leur design et il est peu dire que nous autres mortel·le·s en profitons tous les jours.\n\nIl est peu dire que cet opérateur[^pipe] a révolutionné R, lorsqu'il y a été importé, d'abord dans le package `magrittr` sous sa forme `%>%`. Il est désormais inclus dans le R de \"base\" sous sa forme `|>` mais nous n'utiliserons que la version historique `%>%`, que je trouve plus lisible, plus facile à taper (`<Maj> + <Ctrl/Cmd> + <M>` dans RStudio) et parce que les années aidant, je deviens conservateur.\n\n[^pipe]: À prononcer à l'anglaise hein : \"payeupeu\"\n\nL'idée du pipe est issue de la composition de fonctions en mathématiques. Plutôt que d'écrire :\n\n`h(g(f(x)))` on peut déplier cet emboitement de fonctions et écrire `(h ∘ g ∘ f)(x)`\n\nEn langage R, plutôt que d'écrire `h(g(f(x)))` on écrira : `x %>% f() %>% g() %>% h()`[^pipe2]. Cette écriture est non seulement plus lisible mais elle se lit également de gauche à droite, dans le sens conventionnel de notre partie du monde.\n\n[^pipe2]: Vous pouvez également omettre les parenthèses si vos fonctions sont passées sans argument.\n\n\n## `%>%` vs `|>`\n\nD'abord introduit par le package `magrittr` le forward pipe est désormais dans le R \"de base\" depuis la [version 4.1.0](https://cran.r-project.org/doc/manuals/r-devel/NEWS.html).\n\nLe pipe `|>` tend désormais à être préféré à `%>%` comme on le lira sur le (blog du tidyverse)[, très complet)[https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe/]. Ce dernier mérite néanmoins, avec ses autres copains de `magrittr`, d'être détaillé.\n\nSi la vignette de `magrittr` est très bien faite (`vignette(\"magrittr\"`), j'en livre ici une introduction rapide.\n\n## `%>%` \nDans les grandes lignes, `%>%` et `|>` fonctionnent de la même façon. J'ai tendance à continuer d'utiliser `%>%` qui est chargé automatiquement par le tidyverse. Pour les autres opérateurs, ou si vous n'utilisez pas le tidyverse vous pouvez en disposer avec :\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   4.0.0     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n\nAttaching package: 'magrittr'\n\n\nThe following object is masked from 'package:purrr':\n\n    set_names\n\n\nThe following object is masked from 'package:tidyr':\n\n    extract\n```\n\n\n:::\n:::\n\n\nVenons en aux faits.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrunif(100) %>% mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5606005\n```\n\n\n:::\n:::\n\n\n## Le `.` pour customiser le forward\n\nPar défaut, `%>%` injecte ce qui sort de la fonction à sa gauche comme premier argument de la fonction à sa droite.\n\nLa plupart du temps, notamment avec le tidyverse, cela fonctionne à merveille. Mais pensez à `plot` ou à `lm`, l'argument `data` est le second, pas le premier (qui est une `formula`).\n\n`maggrittr` prévoir ce cas et vous pouvez spécifier un atterrissage alternatif avec `.`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris %>% \n  as_tibble() %>% \n  select(pl=Petal.Length, pw=Petal.Width) %>% \n  lm(pw~pl, data=.)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = pw ~ pl, data = .)\n\nCoefficients:\n(Intercept)           pl  \n    -0.3631       0.4158  \n```\n\n\n:::\n:::\n\n## `%T>%`\nLe \"tee\" pipe est lui utile quand l'une des fonctions est un cul de sac, typiquement un `print` ou un `plot`.\n\nL'idée est, dans un seul pipe, de plotter (ou printer) _mais_ de continuer avec l'objet de départ. En d'autres termes de créer en un point du pipe, une bifurcation dont l'une des branche est un cul de sac, et l'autre continue.\n\nUn exemple vaut mille mots :\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris %>% \n  as_tibble() %>% \n  select(pl=Petal.Length, pw=Petal.Width) %T>% \n  print() %>% # here we print\n  plot(pw~pl, data=.) # and we come back to the object returned by `select`\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 150 × 2\n      pl    pw\n   <dbl> <dbl>\n 1   1.4   0.2\n 2   1.4   0.2\n 3   1.3   0.2\n 4   1.5   0.2\n 5   1.4   0.2\n 6   1.7   0.4\n 7   1.4   0.3\n 8   1.5   0.2\n 9   1.4   0.2\n10   1.5   0.1\n# ℹ 140 more rows\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](magrittr_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n## `%$% \n\nCette variante a pour but d'\"exposer\" le nom des éléments d'une liste, souvent à des fins d'extraction :\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris %>% \n  as_tibble() %>% \n  slice(1:5) %>% \n  select(pl=Petal.Length, pw=Petal.Width) %$% pl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.4 1.4 1.3 1.5 1.4\n```\n\n\n:::\n:::\n\n\nVous pouvez remplacer avantageusement ce pipe par `dplyr::pull` qui est quelque part encore plus conforme à l'esprit \"dplyr/tidyverse\" :\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris %>% \n  as_tibble() %>% \n  slice(1:5) %>% \n  select(pl=Petal.Length, pw=Petal.Width) %>% \n  pull(pw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.2 0.2 0.2 0.2 0.2\n```\n\n\n:::\n:::\n\n\n\n## `%<>%`\n\nDernier opérateur de cette liste, un peu passé de mode mais que je mentionne ici par souci de complétude. Cet opérateur `pipe` part d'un objet, lui fait faire tout le chemin au sein d'un pipe et réassigne l'objet de départ avec l'objet retourné par le pipe :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- iris %>% as_tibble()\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 150 × 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# ℹ 140 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nx %<>% select(1:2)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 150 × 2\n   Sepal.Length Sepal.Width\n          <dbl>       <dbl>\n 1          5.1         3.5\n 2          4.9         3  \n 3          4.7         3.2\n 4          4.6         3.1\n 5          5           3.6\n 6          5.4         3.9\n 7          4.6         3.4\n 8          5           3.4\n 9          4.4         2.9\n10          4.9         3.1\n# ℹ 140 more rows\n```\n\n\n:::\n:::\n\n\nCet opérateur est critique pour un motif recevable : l'assignation est une opération tellement importante qu'elle devrait être plus visible qu'un seul caractère (`%>%` versus `%<>%`).\n\n\n\n\n",
    "supporting": [
      "magrittr_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}