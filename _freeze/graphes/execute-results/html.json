{
  "hash": "4d3e609596fbfec4598210b2bddd1a21",
  "result": {
    "engine": "knitr",
    "markdown": "# Des graphiques\n\nEt on a tous envie de dire, enfin ! Et vue la promesse, on peut faire durer le plaisir et en remettre une petite couche avant, avec la génération de nombres aléatoires.\n\n## Générer des nombres aléatoires\n\n### Au sein d'une séquence existante\n\nLa fonction `sample` permet d'échantillonner au sein d'un vecteur existant. Vous devenz préciser ce vecteur, puis le nombre de tirages à effectuer, avec ou sans remise.\n\nSi vous n'avez pas de dé, en voilà un :\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(1:6, size=1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\nAvec `size=3, replace=TRUE` vous pouvez même jouer au 421. Ou encore générer un tirage de loto sans les boules qui s'agitent :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(1:49, size=6, replace=FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  9 47 36 14  4 34\n```\n\n\n:::\n:::\n\n\nChaque élément du vecteur a autant de chance de sortir qu'un autre.\n\nSi vous préférez le scrabble, vous pouvez aussi utiliser `sample` mais en calibrant l'argument `probs` sur la fréquence des lettres dans la langue française. N'allez donc pas vous taper l'alphabet à la main, jetez un oeil à `letters` et `LETTERS`.\n\n### Distributions existantes\n\nAu delà des vecteurs existants, vous pouvez générer des nombres aléatoires issus d'une distribution. Toutes les distributions disponibles sont listées dans la bien nommée page `?Distributions`.\n\nCes fonctions sont nommées de la façon suivante `{r, p, q, d}nom_abregé_distrib`. La première lettre désigne la variante désirée des différentes fonctions pour une distribution donnée, selon que l'on veuille générer des nombres, la densité de probabilité, les quantiles associés, etc.\n\nPour générer 10 nombres aléatoires compris entre -1 et 1 on peut par exemple :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrunif(10, 0, 1) # see ?runif\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0.1193610 0.4918118 0.7741212 0.3069952 0.7218488 0.4027434 0.4372506\n [8] 0.8760479 0.8498670 0.4134920\n```\n\n\n:::\n:::\n\n\nDans le même esprit on peut tirer 1000 nombres issus d'une distribution normale de moyenne 5 et d'écart-type 3 avec la commande suivante :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(1e3, 5, 3)\nmean(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.028203\n```\n\n\n:::\n\n```{.r .cell-code}\nsd(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.014893\n```\n\n\n:::\n:::\n\n\n`1e3` est la notation dite \"ingénieur\" parfaitement comprise par R. Ici, on a 1 suivi de 3 zéros, soit `10^3` soit `1000`. Vous constaterez également que la moyenne est à peu près de 5 et l'écart type à peu près égal à 3.\n\nSi vous réexécutez cette commande, vous aurez un autre vecteur avec des valeurs différentes mais également à peu près centré sur 5.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- rnorm(1e3, 5, 3)\nmean(x) - mean(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.01312834\n```\n\n\n:::\n:::\n\n\nSi vous désirez générer des nombres aléatoires certes, mais les mêmes, par exemple d'une session à l'autre ou (c'est la même chose) sur l'ordinateur de votre collègue, c'est possible avec la fonction `set.seed`. Du hasard sous contrôle : beauté sans nom !\n\nTapez ceci et comparez avec votre voisin·e.\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2329)\nrnorm(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  0.4446356  1.4954342 -1.9777602  0.1251240 -1.4107758 -1.0692797\n [7] -1.1781869  0.7524880  0.5883426 -0.1579436\n```\n\n\n:::\n:::\n\n\n\n## Premiers graphes\n\nAllez, on y vient. \n\nDécrire un vecteur de nombres avec `mean` et `sd` mais faire des jolis graphes c'est mieux. La commande `plot` est la fonction de base pour ce faire :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(x)\n```\n\n::: {.cell-output-display}\n![](graphes_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nR a compris que chaque valeur du vecteur `x` devait être plottée sur l'axe de ordonnées et en a déduit que l'axe des abscisses devait être la série de 1 à 1000. Ici un histogramme serait plus approprié pour décrire la distribution de notre vecteur de nombres aléatoires :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(y)\n```\n\n::: {.cell-output-display}\n![](graphes_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nOn voit qu'il est bien centré sur `5`. Si l'on augmente le nombre de valeurs générées ainsi que le nombres d'intervalles (`breaks` en anglais), on retrouve une bien belle gaussienne :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(rnorm(1e5, 5, 3), breaks=50, main=\"Un histogramme\")\n```\n\n::: {.cell-output-display}\n![](graphes_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nLes graphiques de base de R sont un peu surannés depuis l’avènement de `gpplot2` que nous verrons en détail plus loin mais ils ont encore leur mot à dire, même s'il ne s'exprimeront pas longuement ici.\n\nVoyons tout de même ce que l'on peut faire avec `iris`, l'un des nombreux jeux de données livrés avec R[^graphes-1].\n\n[^graphes-1]: voir `?datasets`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(Petal.Length~Petal.Width, data=iris, col=Species,\n     xlab=\"Largeur de pétale (cm)\", ylab=\"Longueur de pétale (cm)\",\n     main=\"Les fameux iris de Fisher (voire d'Anderson)\")\n```\n\n::: {.cell-output-display}\n![](graphes_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nEn petit aguichage `ggplot2` voilà ce qu'on peut obtenir dans le même temps :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nggplot(iris) + \n  aes(x=Petal.Width, y=Petal.Length, col=Species) + \n  geom_jitter(alpha=0.5) +\n  geom_smooth(method=\"lm\", formula=\"y~x\") +\n  facet_grid(~Species) +\n  xlab(\"Largeur de pétale (cm)\") + \n  ylab(\"Longueur de pétale (cm)\") +\n  ggtitle(\"Les fameux iris de Fisher (voire d'Anderson)\") +\n  theme_linedraw()\n```\n\n::: {.cell-output-display}\n![](graphes_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "graphes_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}